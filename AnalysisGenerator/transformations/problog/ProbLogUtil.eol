import "StringOps.eol";

//
// ProbLogProgram containment getters methods which either create a new instance, or retrieve an existing one.
//
@cached
operation getAtom(name : String){ 
	var result = new ProbLog!Atom;
	result.name = name.prologize();
	return result;
}

@cached
operation getTerm(name : String, argumentCount : Integer){
	var tname = name.prologize();
	var terms = program().terms->select(term | 
		term.name.equals(tname) and term.arguments.equals(argumentCount)
	);
	if(terms->isEmpty()){
		var result = new ProbLog!Term;
		program().terms.add(result);
		result.name = tname;
		result.arguments = argumentCount;
		return result;
	}else{
		return terms->first();
	}
}

@cached
operation getVariable(name: String){
	var newVar = new ProbLog!Variable;
	newVar.name = name.variablize();
	return newVar;
}


//Creates a new instance of the given term with the given arguments 
operation ProbLog!Term getInstance(arguments: List<ProbLog!Referable>) : ProbLog!TermInstance {
	var result = new ProbLog!TermInstance();
	result.template = self;
	result.arguments = arguments;
	return result;
}
operation ProbLog!Term getInstance(argument: ProbLog!Referable) : ProbLog!TermInstance { return self.getInstance(List{argument});}

//Creates a new instance of an annotatedReferable annotating this Annotatable
operation ProbLog!Annotatable annotate() : ProbLog!AnnotatedReferable {
	var result = new ProbLog!AnnotatedReferable();
	result.annotates = self;
	return result;
}

operation List<ProbLog!AnnotatedReferable> toLHS() : ProbLog!LHS {
	var res = new ProbLog!LHS();
	res.propositions = self;
	return res;
}

operation ProbLog!AnnotatedReferable setProbability(prob : ProbLog!ProbabilityMeasure){
	assert(self.probabilitymeasure == null, "Probability measure already assigned");
	self.probabilitymeasure = prob;
}

operation ProbLog!AnnotatedReferable setProbability(prob : Real){
	var probl = new ProbLog!ProbabilityLiteral();
	probl.value = prob;
	self.setProbability(probl);
}

operation ProbLog!AnnotatedReferable setProbability(nominator : Integer, denominator : Integer){
	var probl = new ProbLog!ProbabilityFraction();
	probl.nominator = nominator;
	probl.denominator = denominator;
	self.setProbability(probl);
}

operation insertComment(){insertComment(null);}
operation insertComment(text : String){
	var comment = new ProbLog!Comment();
	comment.text = text;
	program().statements.add(comment);
}

operation ProbLog!ProbLogProgram useLibrary(name : String){
	var libimport = new ProbLog!ImportLibrary();
	libimport.name = name;
	self.statements.add(libimport);
}

operation cheat(cheatText : String){
	var cheat = new ProbLog!Cheat();
	cheat.contents = cheatText;
	program().statements.add(cheat);
}

operation createList(contents : List<ProbLog!Referable>) : ProbLog!PLList {
	var result = new ProbLog!PLList();
	result.contents = contents;
	return result;
}

operation createTuple(contents : List<ProbLog!Referable>) : ProbLog!PLTuple {
	var result = new ProbLog!PLTuple();
	result.contents = contents;
	return result;
}

operation getNot() : ProbLog!Term {
	return getTerm("not",1);
}


/**
 * Generates a unique name by adding a unique id at the end
 */
operation getUniqueName(name : String) : String {
	var id = program().~idcounter++;
	return name+id;
}

operation String asVariable() : ProbLog!Variable {
	return getVariable(self);
}

operation String asAtom() : ProbLog!Atom {
	return getAtom(self);
}

operation createRule(lhs : ProbLog!Annotatable) : ProbLog!Rule { return createRule(List{lhs});}
operation createRule(lhs : List<ProbLog!Annotatable>) : ProbLog!Rule { return createRule(lhs,List{});}
operation createRule(lhs : List<ProbLog!Annotatable>, rhs : List<ProbLog!Refereable>) : ProbLog!Rule {
	var result = new ProbLog!Rule();
	result.lhs = lhs->collect(a | a.annotate()).toLHS();
	if(not rhs->isEmpty()){
		result.rhs = new ProbLog!RHS();
		result.rhs.conjunction.addAll(rhs);
	}
	return result;
}

// Creates a list of variables which are all underscores
operation getUnderscores(count : Integer) : Collection<ProbLog!Variable> {
	var seq = 1.iota(count,1); //use 'iota' instead of 'to' because 'to' is a reserved keyword
	return seq->collect(i | getVariable("_"));
}

operation findPropertyOwnerFromExpression(prop : PVA!ProbabilisticProperty) : PVA!ConcreteType {
	return prop.eContainer(); 
}

operation findPropertyOwnerFromExpression(expr : PVA!ProbabilisticExpression) : PVA!ConcreteType {
		var probcode = expr;
		while(not probcode.isKindOf(PVA!ProbabilisticCode)){
			probcode = probcode.eContainer();
		}
		var prop = probcode.eContainer();
		return findPropertyOwnerFromExpression(prop);
}


operation createInstanceDefinition(instance : PVA!AssetType) : ProbLog!TermInstance {
	return getTerm("instance",4).getInstance(List{
		getAtom(instance.eClass().name),
		getVariable("ID"),
		getAtom(instance.name),
		getVariable(const().~TEMPLATE_INSTANCE)
	});
}
operation createInstanceDefinition(instance : PVA!DefenceType) : ProbLog!TermInstance {
	return getTerm("instance",4).getInstance(List{
		getAtom(instance.eClass().name),
		getVariable("ID"),
		getAtom(instance.name),
		getVariable(const().~TEMPLATE_INSTANCE)
	});
}  
operation createInstanceDefinition(instance : PVA!AttackStepType) : ProbLog!TermInstance {
	return getTerm("instance",4).getInstance(List{
		getAtom(instance.eClass().name),
		getAtom(instance.target.name),
		getAtom(instance.name),
		getVariable(const().~TEMPLATE_INSTANCE)
	});
}