package nl.utwente

import org.apache.commons.cli.CommandLine
import org.apache.commons.io.FilenameUtils
import org.eclipse.epsilon.emc.emf.EmfModel
import org.eclipse.epsilon.emc.emf.EmfModelFactory
import java.io.BufferedOutputStream
import java.io.FileNotFoundException
import java.nio.file.Files
import java.nio.file.Path
import java.nio.file.Paths
import java.util.*

data class Governor(val parsedArgs: CommandLine, val outputFile : Path) {
    fun execute(){
        useEcoreFromJAR {
            val base = FilenameUtils.removeExtension(outputFile.toString())
            val pvafile = Paths.get(base + "_pva.pl")
            val pvaifile = Paths.get(base + "_pvai.pl")
            val mergedfile = Paths.get(base + "_complete.pl")


            if(parsedArgs.hasOption("pva") || parsedArgs.hasOption("pvai")) {
                val pva = preparePVA()
                if (parsedArgs.hasOption("pva")) {
                    writePVA(pva, pvafile)
                }

                if (parsedArgs.hasOption("pvai")) {
                    writePVAI(pva, pvaifile)
                }
            }

            if(parsedArgs.hasOption("complete")){
                mergeProbLogFiles(mergedfile, pvafile, pvaifile)
            }
        }
    }

    private fun writePVAI(pva: EmfModel, out: Path) {
        val problogOutput = prepareProbLogOutput() //Store ProbLog model in memory
        executePVAIToProbLog(pva, problogOutput)
        problog2text(problogOutput, out)
    }

    private fun writePVA(pva: EmfModel, out: Path) {
        val problogOutput = prepareProbLogOutput() //Store ProbLog model in memory
        executePVAToProbLog(pva, problogOutput)
        problog2text(problogOutput, out)
    }

    /**
     * Merges the generated files
     */
    private fun mergeProbLogFiles(mergedfile: Path, pvafile: Path, pvaifile: Path) {
        if (Files.notExists(pvafile)) {
            throw FileNotFoundException("PVA problog code not found (${pvafile.toAbsolutePath()})")
        }
        if (Files.notExists(pvaifile)) {
            throw FileNotFoundException("PVAI problog code not found (${pvaifile.toAbsolutePath()})")
        }
        mergedfile.toFile().apply {
            this.delete() // Clean up any existing files
            this.outputStream().buffered().use { stream ->
                writeHandCraftedProbLog(stream)
                Files.copy(pvafile, stream)
                Files.copy(pvaifile, stream)
            }
        }
    }

    private fun writeHandCraftedProbLog(problogStream: BufferedOutputStream) {
        listOf("Base.pl","Probabilities.pl","Queries.pl").forEach { handCraftedFile ->
            ClassLoader.getSystemResourceAsStream(handCraftedFile).use {
                it.copyTo(problogStream)
            }
            repeat(2) { problogStream.writeln() }
        }
    }

    private fun preparePVA(): EmfModel {
        println("Loading PVA...")
        val (pathToModel,ecore) = this.parsedArgs.getOptionValue("pva")?.let { it to pathToModels.resolve("pva.ecore") }
            ?: this.parsedArgs.getOptionValue("pvai")!!.let { it to pathToModels.resolve("pvai.ecore") }
        return loadEmfModel(
                "PVA",
                Paths.get(pathToModel).toAbsolutePath().toString(),
                ecore.toString(),
                EmfModelFactory.AccessMode.READ_ONLY
        )
    }

    private fun prepareProbLogOutput(): EmfModel {
        val uniqueID = UUID.randomUUID().leastSignificantBits
        val problogOutput = loadEmfModel(
                "ProbLog",
                "problog_$uniqueID.temp",
                pathToModels.resolve("ProbLog.ecore").toString(),
                EmfModelFactory.AccessMode.WRITE_ONLY
        ).inMemory("ProbLog") //Store ProbLog model in memory
        problogOutput.clearCache()
        return problogOutput
    }

    private fun executePVAIToProbLog(pva : EmfModel, problogOutput: EmfModel) {
        //TODO efficient loading of PVA and PVAI models (no re-loading)
        //TODO can probably be achieved by constructing an in-memory EmfModel
        val pvai = loadEmfModel(
                "PVAI",
                Paths.get(parsedArgs.getOptionValue("pvai")).toAbsolutePath().toString(),
                pathToModels.resolve("pvai.ecore").toString(),
                EmfModelFactory.AccessMode.READ_ONLY
        )
        pvaiToProblog(
                pva,
                pvai,
                problogOutput,
                pathToTransformation.resolve("PVAI_to_ProbLog").resolve("PVAI_to_ProbLog_main.etl")
        )
    }

    private fun executePVAToProbLog(pva : EmfModel, problogOutput: EmfModel) {
        pvaToProblog(
                pva,
                problogOutput,
                pathToTransformation.resolve("PVA_to_ProbLog").resolve("PVA_to_ProbLog_main.etl")
        )
    }

    private inline fun useEcoreFromJAR(op : (() -> Unit)){
        extractEcoreFromJAR()
        op.invoke()
        //Remove temp files
        tempdir.toFile().deleteRecursively()
    }

    private fun extractEcoreFromJAR() {
        val pvaOut = pathToModels.resolve("pva.ecore")
        val pvaiOut = pathToModels.resolve("pvai.ecore")
        val probLogOut = pathToModels.resolve("ProbLog.ecore")
        val files = listOf(pvaOut, pvaiOut, probLogOut)

        files.filterNot { Files.exists(it) }.apply {
            if (this.isNotEmpty()) {
                this.forEach { newFile ->
                    Files.createFile(newFile)
                    copyResourceToPath(newFile)
                }
            }
        }
    }

    private fun copyResourceToPath(outputLocation: Path) {
        ClassLoader.getSystemResourceAsStream(
                outputLocation.fileName.toString()
        ).use { jarStream ->
            outputLocation.toFile().outputStream().use { fileStream ->
                jarStream.copyTo(fileStream)
            }
        }
    }
}

