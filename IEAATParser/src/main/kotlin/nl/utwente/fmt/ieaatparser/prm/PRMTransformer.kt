package nl.utwente.fmt.ieaatparser.prm

import ics.eaat.abstractmodeller.newmodel.*
import nl.utwente.fmt.ieaatparser.antlr.*
import nl.utwente.fmt.ieaatparser.destructurePartition
import nl.utwente.fmt.ieaatparser.generateUUID
import org.antlr.v4.runtime.ANTLRInputStream
import org.antlr.v4.runtime.BailErrorStrategy
import org.antlr.v4.runtime.CommonTokenStream
import org.apache.commons.io.input.ReaderInputStream
import pva.*
import pva.probcode.ProbabilisticCode
import java.io.StringReader
import java.nio.charset.Charset

/**
 * Constants
 */
val CONST_ASSET = "Asset"
val CONST_ATTACKSTEP = "AttackStep"
val CONST_DEFENCE = "Defense"
val CONST_ATTACKER = "Attacker"
val CONST_FUNCTIONING = "Functioning"
val CONST_LIKELIHOOD = "Likelihood"
val CONST_WORKDAYS = "Workdays"
val TOP_LEVEL_CYSEMOL_CLASSES = listOf(CONST_ASSET, CONST_ATTACKSTEP, CONST_DEFENCE, CONST_ATTACKER)

val CONST_GETPATHS = "getPaths"
val CONST_ISACCESSIBLE = "isAccessible"
val CONST_ISFUNCTIONING = "isFunctioning"
val USEFUL_P2AMF_METHODS = listOf(CONST_ISACCESSIBLE, CONST_ISFUNCTIONING)

val pvaFactory: PVAFactory = PVAFactory.eINSTANCE

/**
 * Map which allows the exporter to export the correct type of invalid orphaned PRM objects
 */
val ORPHAN_FIX: Map<String, ConcreteType> = mapOf(
        "BypassDetectionSystems" to pvaFactory.createAttackStepType().apply {
            name ="BypassDetectionSystems"
            uuid = generateUUID()
            succeeded = pvaFactory.createProbabilisticProperty().apply {
                uuid = generateUUID()
            }
        }, "NetworkVulnerabilityScanner" to pvaFactory.createDefenceType().apply {
            name ="NetworkVulnerabilityScanner"
            uuid = generateUUID()
            functioning = pvaFactory.createProbabilisticProperty().apply {
                uuid = generateUUID()
            }
        }
)


/**
 * Class containing methods for converting the CySeMoL PRM to an instance of the new EMF PRM model
 */
data class PRMTransformer(val classes : List<OCLClass>) {

    fun parse(): PVAContainer {
        val modelContainer = pvaFactory.createPVAContainer()

        //ensure all instances are generated first
        generateConcreteTypes(classes, modelContainer)

        //generate all relevant template instances
        generateTemplates(classes, modelContainer)

        //afterwards, instantiate all relations
        generateAssetRelations(classes, modelContainer)

        //finally parse the P2AMF code, which needs references to all classes
        generateP2AMFTypes(classes, modelContainer)

        generateVirtualConnections(modelContainer)

        return modelContainer
    }

    private fun generateVirtualConnections(modelContainer: PVAContainer) {
        modelContainer.concreteTypes.flatMap {
            it.connectedTo
        }.filterIsInstance<VirtualConnection>().forEach { edge ->
            parseVirtualEdge(edge,virtualConnectionLookup[edge]!!,modelContainer)
        }
    }

    /**
     * Generates all relevant template instances:
     * Template Definitions
     * Template Connections (connectionPorts)
     * Template Properties (attributes)
     */
    private fun generateTemplates(classes: List<OCLClass>, pvaModel: PVAContainer) {
        classes.flatMap {
            it.allInstances.map { it.parent }
        }.distinct().map {
            it as MetaTemplate
        }.filterNot {
            it.name == CONST_ATTACKER
        }.forEach { metatemplate ->

            // Template definitions
            val templateDef = createTemplateDefinition(metatemplate, pvaModel)

            // TemplateDefinition.TypeInstantiation.properties association
            metatemplate.attributes.forEach { attribute ->
                val instantiation = templateDef.instantiations.singleOrNull { it.name == attribute.owner.name }
                    ?: throw RuntimeException("Ambiguous or no instantiation found for ${templateDef.name}->${attribute.owner.name}")

                instantiation.properties += when(attribute.attribute.name){
                    CONST_FUNCTIONING -> {
                        (instantiation.concretization as DefenceType).functioning
                    }
                    CONST_LIKELIHOOD -> {
                        (instantiation.concretization as AttackStepType).succeeded
                    }
                    else -> throw RuntimeException("Unsupported attribute ${attribute.attribute.completeName}")
                }
            }

            // Store the created template definition
            pvaModel.templateTypes += templateDef
        }
    }

    private fun createTemplateDefinition(metatemplate: MetaTemplate, pvaModel: PVAContainer): TemplateDefinition {
        return pvaFactory.createTemplateDefinition().apply {
            uuid = generateUUID()
            name = metatemplate.toTemplateName()

            val templateObjects = metatemplate.templateChildren.filter {
                it.name != CONST_WORKDAYS
            }.map {
                it as TemplateObject
            }

            // Generate type instantiations
            instantiations += templateObjects.distinctBy {
                it.name //discard double named template objects
            }.map { templateObject ->
                val instanceName = templateObject.name
                val className = templateObject.oclClass.name
                pvaFactory.createTypeInstantiation().apply {
                    name = instanceName
                    uuid = generateUUID()
                    concretization = lookupConcrete(className, pvaModel, { "Failed to find Concrete Type $className" })
                }
            }

            //Generate instantiation and external connections
            templateObjects.forEach { templateObject ->
                val currentInstantiation = instantiations.singleOrNull { it.name == templateObject.name }
                        ?: throw RuntimeException("No unique instantiation not found! ${templateObject.name}")

                //create instantiation connections
                currentInstantiation.internalConnections += templateObject.associations.filter {
                    "Functioning" !in listOf(it.childPort.owner.name, it.parentPort.owner.name)
                }.map { association ->
                    //Determine source and target ports from our perspective
                    val (sourcePort, targetPort) = listOf<Port>(association.childPort, association.parentPort).partition {
                        it.owner.name == templateObject.name
                    }.destructurePartition()


                    //Create the actual connection
                    assert(sourcePort.owner.name == templateObject.name, { "${sourcePort.owner.name} is not equal to ${templateObject.name}" })
                    pvaFactory.createInstantiationConnection().apply {
                        uuid = generateUUID()
                        label = sourcePort.name
                        target = instantiations.singleOrNull { it.name == targetPort.owner.name } ?:
                                throw RuntimeException("No unique instantiation target found for ${targetPort.owner.name}")
                        concretization = pvaModel.concreteTypes.flatMap {
                            it.connectedTo
                        }.singleOrNull {
                            it.name == sourcePort.reference.toEdgeName(
                                    sourcePort.reference.childClass.name == sourcePort.connectionEnd.name
                            )
                        } ?: throw RuntimeException("Concrete relation not found! ${sourcePort.name}")
                    }
                }

                val internalPorts = templateObject.associations.flatMap {
                    listOf(it.childPort, it.parentPort)
                }

                currentInstantiation.externalConnections += templateObject.connectionPorts.filter {
                    it !in internalPorts // Skip ports with internal associations
                }.filterNot {
                    it.connectionEnd.name == CONST_ATTACKSTEP
                }.map { port ->
                    val reversed = port.reference.parentClass != templateObject.oclClass
                    pvaModel.concreteTypes.flatMap {
                        it.connectedTo
                    }.singleOrNull {
                        it.name == port.reference.toEdgeName(reversed)
                    } ?: throw RuntimeException("Concrete relation not found! ${port.name}")
                }
            }
        }
    }

    /**
     * Generates all relevant concrete types, being:
     * -Asset Types
     * -Defence Types
     * -AttackStep Types
     * -Concrete Connections
     */
    private fun generateConcreteTypes(classes: List<OCLClass>, pvaModel: PVAContainer) {
        val nonTopLevelClasses = classes.filter {
            it.name !in TOP_LEVEL_CYSEMOL_CLASSES
        }

        //Assets, Defences, and AttackSteps
        nonTopLevelClasses.forEach {
            pvaModel.concreteTypes += when (it.superclass?.name) {
            //Asset types
                CONST_ASSET ->
                    pvaFactory.createAssetType().apply {
                        uuid = generateUUID()
                        name = it.name
                    }
            //Attack step types
                CONST_ATTACKSTEP ->
                    pvaFactory.createAttackStepType().apply {
                        uuid = generateUUID()
                        name = it.name
                        succeeded = pvaFactory.createProbabilisticProperty().apply {
                            name = "succeeded"
                            uuid = generateUUID()
                        }
                    }
            //Defence types
                CONST_DEFENCE ->
                    pvaFactory.createDefenceType().apply {
                        uuid = generateUUID()
                        name = it.name
                        functioning = pvaFactory.createProbabilisticProperty().apply {
                            name = "functioning"
                            uuid = generateUUID()
                        }
                    }
                else ->
                    if (it.name in ORPHAN_FIX.keys) {
                        println("Warn: ${it.name} has no valid parent, applying fix...")
                        ORPHAN_FIX[it.name]
                    } else {
                        throw RuntimeException("Error: ${it.name} has no valid parent and has no fix.")
                    }
            }
        }

        //Assumption: All concrete types have been created at this point
        //Concrete connections
        nonTopLevelClasses.flatMap {
            it.references
        }.distinct().forEach { reference ->
            createConnection(reference, pvaModel)
        }
    }

    private fun createConnection(reference: Reference, pvaModel : PVAContainer) {
        val sourceType = lookupConcrete<ConcreteType>(reference.parentClass.name, pvaModel, {"Source lookup failed ${reference.parentClass.name}"})
        val targetType = lookupConcrete<ConcreteType>(reference.childClass.name, pvaModel, {"Target lookup failed ${reference.childClass.name}"})

        //parent -> child
        newConnection(reference,false).apply {
            uuid = generateUUID()
            name = reference.toEdgeName(false)
            label = reference.parentToChildLabel
            relationName = reference.label
            target = targetType
        }.apply {
            sourceType.connectedTo += this
        }

        //child -> parent
        newConnection(reference,true).apply {
            uuid = generateUUID()
            name = reference.toEdgeName(true)
            label = reference.childToParentLabel
            relationName = reference.label
            target = sourceType
        }.apply {
            targetType.connectedTo += this
        }
    }

    //Store the original reference for each virtualconnection for easy lookup later
    private val virtualConnectionLookup = mutableMapOf<VirtualConnection,Reference>()
    private fun newConnection(ref : Reference, reversed: Boolean = false) : ConcreteConnection = if(ref.derivedBody==null){
        pvaFactory.createConcreteConnection()
    }else{
        pvaFactory.createVirtualConnection().apply {
            this.isReversed = reversed
            virtualConnectionLookup[this] = ref
        }
    }

    /**
     * Generate all asset relations
     * AssetType.attackedBy
     * AssetType.defendedBy
     */
    private fun generateAssetRelations(classes: List<OCLClass>, pvaModel: PVAContainer) {
        val assets = classes.filter {
            it.superclass?.name == CONST_ASSET
        }
        val attackSteps = classes.filter {
            it.superclass?.name == CONST_ATTACKSTEP
        }

        generateAssetTypeAttackedBy(assets, pvaModel)
        generateAssetTypeDefendedBy(assets, pvaModel)
        generateAttackStepEnables(attackSteps, pvaModel)
    }

    private fun generateAssetTypeDefendedBy(assets: List<OCLClass>, pvaModel: PVAContainer) {
        generateAssetTypeAssociation<DefenceType>(assets, pvaModel, CONST_DEFENCE, { asset, defence ->
            asset.defendedBy += defence
        })
    }

    private fun generateAssetTypeAttackedBy(assets: List<OCLClass>, pvaModel: PVAContainer) {
        generateAssetTypeAssociation<AttackStepType>(assets, pvaModel, CONST_ATTACKSTEP, { asset, atstep ->
            atstep.target = asset // Note: source and target are swapped with regard to the generateAssetTypeDefendedBy method!!!
        })
    }


    /**
     * Helper method for assigning the Xby associations of AssetTypes
     */
    inline private fun <reified T : ConcreteType> generateAssetTypeAssociation(
            assets: List<OCLClass>,
            pvaModel: PVAContainer,
            typeString: String,
            assignToLookup: ((AssetType, T) -> (Unit))) {
        assets.forEach { oclAsset ->
            //Get the PVA class for the this asset
            val assetName = oclAsset.name
            val asset: AssetType = lookupConcrete(assetName, pvaModel, {
                "Asset lookup failed $assetName"
            })

            oclAsset.references.filter {
                it.parentClass?.superclass?.name == typeString //Only consider references from the correct type
            }.forEach { reference ->
                assignToLookup(asset,
                        lookupConcrete(reference.parentClass.name, pvaModel, {
                            "$typeString lookup failed: ${reference.parentClass.name}"
                        })
                )
            }
        }
    }

    /**
     * Generate 'enables' edges between attack steps
     */
    private fun generateAttackStepEnables(attackSteps: List<OCLClass>, pvaModel: PVAContainer) {
        attackSteps.forEach { attackStepClass ->
            val attackStepType = lookupConcrete<AttackStepType>(attackStepClass.name,pvaModel)
            val code = attackStepClass.operations.single {
                it.name == CONST_GETPATHS
            }.body
            attackStepType.enables += parseGetPaths(attackStepType,code).distinct()
        }
    }

    /**
     * Generates all properties present in the CySeMoL
     */
    private fun generateP2AMFTypes(classes: List<OCLClass>, pvaModel: PVAContainer) {
        classes.filter {
            it.name !in TOP_LEVEL_CYSEMOL_CLASSES
        }.flatMap { oclclass -> //obtain all method bodies
            oclclass.operations.filter {
                it.body != null
            }.map { op ->
                P2AMFOperation(oclclass, op.name, op.body)
            }
        }.filter { //only store useful methods
            it.operationName in USEFUL_P2AMF_METHODS
        }.distinctBy { it.body }.forEach { p2amfdef ->
            val operationOwner: ConcreteType = lookupConcrete(p2amfdef.parent.name, pvaModel, {
                "Owner of operation ${p2amfdef.qualifiedName} not found."
            })

            parseP2AMF(pvaModel, operationOwner, p2amfdef).let { implementation ->
                when(operationOwner){
                    is DefenceType -> operationOwner.functioning.implementation = implementation
                    is AttackStepType -> operationOwner.succeeded.implementation = implementation
                    else -> throw IllegalStateException("Illegal owner type")
                }
            }
        }
    }


    /**
     * Invokes the ANTLR4 parser, and converts its AST to the P2AMF metamodel
     */
    private fun parseP2AMF(model: PVAContainer, owner: ConcreteType, code: P2AMFOperation): ProbabilisticCode {
        ReaderInputStream(StringReader(code.body), Charset.defaultCharset()).use { stream ->
            val lexer = P2AMFLexer(ANTLRInputStream(stream))
            val parser = P2AMFParser(CommonTokenStream(lexer)).apply {
                this.buildParseTree = true
                this.errorHandler = BailErrorStrategy()
            }
            val parseTree = parser.program()
            return P2AMFBuilder(pva = model, codeOwner = owner).visitProgram(parseTree)
        }
    }

    /**
     * Invokes the ANTLR4 parser, and converts its AST to the P2AMF metamodel
     */
    private fun parseGetPaths(owner: AttackStepType, code: String) : List<AttackStepType> {
        ReaderInputStream(StringReader(code), Charset.defaultCharset()).use { stream ->
            val lexer = GetPathsLexer(ANTLRInputStream(stream))
            val parser = GetPathsParser(CommonTokenStream(lexer)).apply {
                this.buildParseTree = true
                this.errorHandler = BailErrorStrategy()
            }
            val parseTree = parser.paths()
            return GetPathsBuilder(owner).getEnables(parseTree)
        }
    }

    /**
     * Invokes the ANTLR4 parser, and converts its AST to the P2AMF metamodel
     */
    private fun parseVirtualEdge(edge: VirtualConnection, ref: Reference, modelContainer: PVAContainer) {
        // For virtual edges, the parent of the edge is the perspective of the derivation
        val derivationContext: ConcreteType = lookupConcrete(ref.parentClass.name,modelContainer)

        ReaderInputStream(StringReader(ref.derivedBody), Charset.defaultCharset()).use { stream ->
            val lexer = VirtualEdgesLexer(ANTLRInputStream(stream))
            val parser = VirtualEdgesParser(CommonTokenStream(lexer)).apply {
                this.buildParseTree = true
                this.errorHandler = BailErrorStrategy()
            }
            val parseTree = parser.path()

            //Find the connections, and add them to the edge
            edge.path += VirtualEdgeBuilder(derivationContext,edge).buildEdges(parseTree)
        }
    }
}