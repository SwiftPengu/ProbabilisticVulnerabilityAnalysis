package nl.utwente.fmt.ieaatparser.eom

import ics.eaat.abstractmodeller.newmodel.MetaTemplate
import ics.eaat.abstractmodeller.newmodel.Port
import ics.eaat.abstractmodeller.newmodel.TemplateObject
import nl.utwente.fmt.ieaatparser.generateUUID
import nl.utwente.fmt.ieaatparser.io.IEaatParts
import nl.utwente.fmt.ieaatparser.prm.*
import org.xml.sax.Attributes
import org.xml.sax.helpers.DefaultHandler
import pva.*
import pvai.PVAIContainer
import pvai.PVAIFactory
import pvai.TemplateInstance
import javax.xml.parsers.SAXParserFactory


val pvaiFactory : PVAIFactory = PVAIFactory.eINSTANCE
val EOM_ROOT_NODE = "se.kth.ics.eaat.objectmodel:XMIObjectModel"
val EOM_OBJECT_NODE = "objects"
val EOM_EVIDENCE_NODE = "evidenceAttributes"
val EOM_ASSOCIATIONS_NODE = "associations"

val EOM_ATTR_METACONCEPT = "metaConcept"
val EOM_ATTACKER_CONCEPT = "Attacker"
val EOM_TIME_PROPERTY = "Time"

//TODO retrieve id from the PRM instead of using a hardcoded id
val ATTACKER_PRM_ID = 1356031135600

val EOM_OBJECT_ATTR_NAME = "name"
val EOM_OBJECT_ATTR_ID = "id"

val EOM_EVIDENCE_ATTR_EVIDENCE = "evidence"

val EOM_ASSOC_ATTR_PARENTOBJECT = "parentObject"
val EOM_ASSOC_ATTR_CHILDOBJECT = "childObject"


/**
 * SAX parser which parsers .eom (XMI) files contained in CySeMoL output files
 */
class EOMParser(val pvaModel : PVAContainer, val parts : IEaatParts) : DefaultHandler() {
    private var result : PVAIContainer = pvaiFactory.createPVAIContainer()
    var templateInstanceScope: TemplateInstance? = null
    var attackerID : Long? = null

    val idMap : MutableMap<Long, TemplateInstance> = mutableMapOf()

    override fun startDocument() {
        super.startDocument()
        println("Starting reading EOM file")
    }

    override fun startElement(uri: String, localName: String, qName: String, attributes: Attributes) {
        super.startElement(uri, localName, qName, attributes)
        when(qName){
            EOM_ROOT_NODE -> {} //root node
            EOM_OBJECT_NODE -> handleObjectNode(attributes) //Template instances
            EOM_EVIDENCE_NODE -> handleEvidenceNode(attributes) //Evidence
            EOM_ASSOCIATIONS_NODE -> handleAssociation(attributes) //Associations between templates

            //No other attributes supported, so throw exception
            else -> throw RuntimeException("Encountered unknown XML tag: $qName")
        }
    }

    /**
     * Processes an encountered object node
     */
    private fun handleObjectNode(attributes: Attributes) {
        val metaConceptName = attributes.getValue(EOM_ATTR_METACONCEPT)
        when (metaConceptName) {
            EOM_ATTACKER_CONCEPT -> {
                //Store the attacker
                //TODO warn instead of crash, and ignore additional attackers instead
                assert(result.attacker == null, { "EOM file defines more than one attacker, this is currently not supported" })
                result.attacker = pvaiFactory.createAttacker().apply {
                    this.name = attributes.getValue(EOM_OBJECT_ATTR_NAME)
                }
                attackerID = attributes.getValue(EOM_OBJECT_ATTR_ID).toLong()
            }
            else -> {
                var newName = attributes.getValue(EOM_OBJECT_ATTR_NAME)
                idMap.values.find {
                    it.name.equals(newName, ignoreCase = true)
                }?.let { offender ->
                    println("Warning: duplicate template name '$newName', this is currently not supported, and the output might be incorrect.")
                    newName = generateUniqueName(newName)
                    println("Auto-renamed to $newName")
                }
                val newInstance = pvaiFactory.createTemplateInstance().apply {
                    uuid = generateUUID()
                    name = newName
                    definition = lookupTemplate(metaConceptName.toTemplateName(), pvaModel)
                }
                result.pvaiTypes += newInstance
                templateInstanceScope = newInstance
                idMap.put(attributes.getValue(EOM_OBJECT_ATTR_ID).toLong(), newInstance)
            }
        }
    }

    /**
     *  Finds the first integer which, when appended to the given template name, leads to a unique template name
     */
    private fun generateUniqueName(newName: String): String {
        //Beware the use of the very large finite sequence
        val allPositiveIntegers = (1 .. Integer.MAX_VALUE).asSequence()
        val uniqueID = allPositiveIntegers.dropWhile { index ->
            idMap.values.find { templateInstance ->
                "$newName$index".equals(templateInstance.name, ignoreCase = true)
            } != null
        }.first()
        return newName + uniqueID
    }

    /**
     * Processes an encountered evidence node
     */
    private fun handleEvidenceNode(attributes: Attributes) {
        val metaConceptName = attributes.getValue(EOM_ATTR_METACONCEPT)
        if(metaConceptName.equals("$EOM_ATTACKER_CONCEPT.$EOM_TIME_PROPERTY", ignoreCase = true)){
            println("Skipping attacker time evidence")
        }else{
            val context = this.templateInstanceScope!!
            context.evidence += pvaiFactory.createEvidence().apply {
                this.uuid = generateUUID()
                this.name = "${context.name}.$metaConceptName"
                this.value = attributes.getValue(EOM_EVIDENCE_ATTR_EVIDENCE).toBoolean()
                val (targetName, attributeName) = metaConceptName.split(".").let { it[0] to it[1] }

                val candidateInstantiation = context.definition.instantiations.filter { it.concretization.name.equals(targetName, true) }

                // Sanity check whether evidence resolution is ambiguous (possible through a bug in EAAT)
                if(candidateInstantiation.size > 1) {
                    println("Warning: ambiguous evidence, resolving to ${context.name}->${candidateInstantiation.first().name}.$attributeName")
                }
                this.propertyOwner = candidateInstantiation.firstOrNull() //use first instead of single (CySeMoL bug)
                        ?: throw RuntimeException("Unable to find unambiguous instantiation for property ${context.name}->$targetName.$attributeName")

                this.target = when(attributeName){
                    CONST_FUNCTIONING -> {
                        (propertyOwner.concretization as DefenceType).functioning
                    }
                    CONST_LIKELIHOOD -> {
                        (propertyOwner.concretization as AttackStepType).succeeded
                    }
                    else -> throw RuntimeException("Unsupported attribute type $attributeName")
                }
            }
        }
    }

    private fun handleAssociation(attributes: Attributes) {
        val parentID = attributes.getValue(EOM_ASSOC_ATTR_PARENTOBJECT).toLong()

        val targetID = attributes.getValue(EOM_ASSOC_ATTR_CHILDOBJECT).toLong()
        val targetTemplate = idMap[targetID] ?: throw RuntimeException("Target not found $targetID")
        val label = attributes.getValue(EOM_ATTR_METACONCEPT)

        when (parentID) {
            attackerID -> {
                pvaiFactory.createEntryPoint().apply {
                    assert(attributes.getValue("metaConceptId").toLong() == ATTACKER_PRM_ID) //
                    this.definition = findAttackStepDefinition(label,targetTemplate)
                    this.targetTemplateInstance = targetTemplate
                    this.target = targetTemplate.definition.instantiations.find {
                        it.concretization == definition.target
                    }!!

                    //Add ourselves as an entrypoint
                    result.attacker.entryPoints += this
                }
            }
            else -> {
                val parentTemplate = idMap[parentID] ?: throw RuntimeException("Parent not found $parentID")

                createAndAddAssociation(attributes, label, parentTemplate, targetTemplate)
                createAndAddAssociation(attributes, label, targetTemplate, parentTemplate)
            }
        }
    }

    /**
     * Helper method which adds an association between the given templates with the given label
     */
    private fun createAndAddAssociation(attributes: Attributes,
                                        label: String,
                                        parentTemplate: TemplateInstance,
                                        targetTemplate: TemplateInstance) {
        pvaiFactory.createConnectionTemplate().apply {
            this.`name` = "${parentTemplate.name} -> ${attributes.getValue(EOM_ATTR_METACONCEPT)} -> ${targetTemplate.name}" //Set a name
            this.uuid = generateUUID()
            this.targetOwner = targetTemplate


            //Determine source, target, and concrete connection
            val potentialSourceInstantiations = parentTemplate.definition.instantiations
            val potentialTargetInstantiations = targetTemplate.definition.instantiations
            val legalConnections = potentialSourceInstantiations.flatMap { sourceInstantiation ->
                sourceInstantiation.externalConnections.map { connection ->
                    potentialTargetInstantiations.find { potentialInstantiation ->
                        potentialInstantiation.concretization == connection.target
                    }?.let { potentialInstantiation ->
                        ConnectionTemplateCandidate(sourceInstantiation, potentialInstantiation, connection)
                    }
                }.filterNotNull()
            }
            val connectionData = legalConnections.singleOrNull {
                it.connection.relationName.equals(label, ignoreCase = true)
            } ?: throw RuntimeException("Ambiguous or no connection found ${parentTemplate.name}.$label")

            this.source = connectionData.source
            this.target = connectionData.target
            this.definition = connectionData.connection

            //Find a templateConnection with the same source, target, and label
            this.definition = parentTemplate.definition.instantiations.flatMap {
                it.externalConnections
            }.filter {
                it.relationName.equals(label, ignoreCase = true)
            }.distinct().singleOrNull()
                    ?: throw RuntimeException("Unable to find TemplateConnection definition for ${parentTemplate.name} ($label)")


            //Add ourselves as an association for our parent
            parentTemplate.associations += this
        }
    }

    data class ConnectionTemplateCandidate(val source : TypeInstantiation, val target : TypeInstantiation, val connection: ConcreteConnection)

    /**
     * Finds an attack step which targets the given template using the given relation
     */
    private fun findAttackStepDefinition(label: String, target: TemplateInstance): AttackStepType {
        val attackStepNames = this.parts.classModel.classes.single {
            it.name == CONST_ATTACKER
        }.references.filter {
            it.childToParentLabel == CONST_ATTACKER.toLowerCase()
        }.single {
            it.label == label
        }.allInstances.filterIsInstance<Port>().filter {
            it.owner.name.toTemplateName() == target.definition.name
        }.map {
            when(it.owner){
                //This case should not occur (is filtered by only supporting templates in the EOM)
                is TemplateObject -> {
                    System.err.println("Warning: looking up non-template entry point")
                    it.owner.name
                }
                is MetaTemplate -> {
                    (it.templateChildren.single().owner as TemplateObject).oclClass.name
                }
                else -> throw IllegalStateException("Unsupported class ${it.javaClass}")
            }
        }

        val attackStepName = attackStepNames.first() //Select the first option when there are multiple
        if(attackStepNames.size > 1) println("Warn: ambiguous entry point, defaulting to $attackStepName")

        //Obtain the matching AttackStepType from the PVA
        return lookupConcrete(attackStepName,pvaModel){
            "Unable to find attack step $attackStepName"
        }
    }

    override fun endElement(uri: String, localName: String, qName: String) {
        super.endElement(uri, localName, qName)
        if (qName == EOM_OBJECT_NODE) {
            templateInstanceScope = null //reset object scope
        }
    }

    override fun endDocument() {
        println("Finished reading EOM file")
    }

    /**
     * Runs the parser, and returns a container as specified by the provided EOM part.
     */
    fun parse(): PVAIContainer {
        this.result = pvaiFactory.createPVAIContainer()
        SAXParserFactory.newInstance().newSAXParser().parse(parts.eom, this)
        return this.result
    }
}