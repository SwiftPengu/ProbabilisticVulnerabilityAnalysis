package nl.utwente.fmt.ieaatparser.antlr

import nl.utwente.fmt.ieaatparser.antlr.GetPathsParser.*
import pva.AttackStepType

/**
 * Class containing parsing methods for obtaining the attackstep references in the getPaths() methods
 */
data class GetPathsBuilder(val context: AttackStepType){
    /**
     * Builds a list of attacksteps, which are enabled by our current context
     */
    fun getEnables(pathsNode : PathsContext) : List<AttackStepType> = when {
        pathsNode.TARGET()!=null -> {
            listOf()
        }
        pathsNode.attackStepList()!=null -> {
            parseAttackStepList(pathsNode.attackStepList())
        }
        else -> throw IllegalStateException("No valid parsing options")
    }


    private fun parseAttackStepList(attackStepList: AttackStepListContext): List<AttackStepType> {
        val result = mutableListOf(parseAttackStepReference(attackStepList.attackStepReference()))

        //Null-safe invocation on union()
        attackStepList.union()?.let { union ->
            result += union.map(UnionContext::attackStepReference).map {
                parseAttackStepReference(it)
            }
        }
        return result
    }

    private fun parseAttackStepReference(attackStepReference: AttackStepReferenceContext): AttackStepType {
        val edgename = attackStepReference.reference().ID().text
        val candidateAttackSteps = context.connectedTo.filter{
            it.label == edgename
        }.map {
            it.target
        }.filterIsInstance<AttackStepType>()
        if(candidateAttackSteps.isEmpty()){
            throw RuntimeException("Edge not found: ${context.name}.$edgename")
        }
        return candidateAttackSteps.singleOrNull() ?: throw RuntimeException("Ambiguous edge: ${context.name}.$edgename")
    }
}