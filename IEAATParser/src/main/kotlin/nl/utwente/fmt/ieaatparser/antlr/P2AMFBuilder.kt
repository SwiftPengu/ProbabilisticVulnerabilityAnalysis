package nl.utwente.fmt.ieaatparser.antlr

import nl.utwente.fmt.ieaatparser.antlr.P2AMFParser.*
import nl.utwente.fmt.ieaatparser.generateUUID
import org.antlr.v4.runtime.ParserRuleContext
import org.antlr.v4.runtime.tree.TerminalNode
import pva.*
import pva.probcode.*

data class P2AMFBuilder(val factory: ProbcodeFactory = ProbcodeFactory.eINSTANCE, val pva: PVAContainer, val codeOwner: ConcreteType){
    var root : ProbabilisticCode? = null

    fun visitProgram(ctx: ProgramContext): ProbabilisticCode = factory.createProbabilisticCode().apply {
        root = this //store root of the program
        this.distributions += ctx.letblock().map { visitLetblock(it) }
        this.expression = visitExpression(ctx.expression()!!)
    }

    fun visitLetblock(ctx: LetblockContext) : NamedDistribution = factory.createNamedDistribution().apply {
        name = ctx.ID()!!.text
        definition = visitProbabilitydistribution(ctx.probabilitydistribution())
        uuid = generateUUID()
    }

    fun visitExpression(ctx: ExpressionContext): ProbabilisticExpression = when {
        //And expression
        ctx.AND()!=null ->  factory.createAnd().apply {
            children += visitExpression(ctx.left)
            children += visitExpression(ctx.right)
        }

        //Or expression
        ctx.OR()!=null -> factory.createOr().apply {
            children += visitExpression(ctx.left)
            children += visitExpression(ctx.right)
        }

        //Not expression
        ctx.NOT()!=null -> factory.createNot().apply {
            child = visitExpression(ctx.expr)
        }

        //If-then-else expression
        ctx.ifthenelse()!=null -> visitIfthenelse(ctx.ifthenelse())

        //Operand
        ctx.operands()!=null -> visitOperands(ctx.operands())

        //Nested expression (in parentheses)
        ctx.expression()!=null -> visitExpression(ctx.expression(0))
        else -> edgeCaseFailWithContext(ctx)
    }

    fun visitIfthenelse(ctx: IfthenelseContext): ProbabilisticExpression {
        val c = visitExpression(ctx.condition)
        val t = visitExpression(ctx.t)
        val f = visitExpression(ctx.f)

        val preOptimized = when {
            //Optimize if !x then a else b -> if x then b else a
            (c is Not) -> {
                factory.createIfThenElse().apply {
                    this.condition = c.child
                    this.`true` = f
                    this.`false` = t
                }
            }
            else -> {
                factory.createIfThenElse().apply {
                    this.condition = c
                    this.`true` = t
                    this.`false` = f
                }
            }
        }
        return preOptimized.let {
            val updatedC = it.condition
            val updatedT = it.`true`
            val updatedF = it.`false`
            when {
                //Optimize if x then a else false -> x and a
                (updatedF is Constant && updatedF.value==0.0) -> {
                    factory.createAnd().apply {
                        this.children+= updatedT
                        this.children+= updatedC
                    }
                }
                //Optimize if (x) then true else false -> x
                (updatedT is Constant && updatedF is Constant && updatedT.value==1.0 && updatedF.value==0.0) -> {
                    updatedC
                }
                //Optimize if (x) then false else true -> not x
                (updatedT is Constant && updatedF is Constant && updatedT.value==0.0 && updatedF.value==1.0) -> {
                    //prevent double negation (not not x <=> x)
                    if(updatedC is Not){
                        updatedC.child
                    }else {
                        factory.createNot().apply {
                            child = updatedC
                        }
                    }
                }
                // If no optimizations are possible
                else -> it
            }
        }
    }

    fun visitOperands(ctx: OperandsContext): Operand = when{
        ctx.booleanoperand()!=null -> visitBooleanoperand(ctx.booleanoperand())
        ctx.numberoperand()!=null -> visitNumberoperand(ctx.numberoperand())
        ctx.reference()!=null -> visitReference(ctx.reference())
        else -> edgeCaseFailWithContext(ctx)
    }


    fun visitReference(ctx: ReferenceContext) : Operand {
        return when{
            ctx.attackstepEnabled()!=null -> factory.createConstant().apply { value = 1.0 } //while proving, this is always the case
            ctx.attackstep()!=null -> visitAttackStep(ctx.attackstep())
            ctx.defence()!=null -> visitDefence(ctx.defence())
            ctx.connectionavailable()!=null -> visitConnectionAvailable(ctx.connectionavailable())
            ctx.ID()!=null -> visitProbabilityDistributionReference(ctx.ID())
            else -> edgeCaseFailWithContext(ctx)
        }
    }

    fun visitAttackStep(ctx: AttackstepContext) : AttackStepSucceeded = factory.createAttackStepSucceeded().apply {
        val (type,chain) = visitObjectReference(ctx.objectreference())
        this.type = type as? AttackStepType ?: throw ClassCastException("Expected Attack Step")
        this.referenceChain += chain
    }

    fun visitDefence(ctx: DefenceContext) : DefenceOperational = factory.createDefenceOperational().apply {
        val (type,chain) = visitObjectReference(ctx.objectreference())
        this.type = type as? DefenceType ?: throw ClassCastException("Expected Defence")
        this.referenceChain += chain
    }

    fun visitConnectionAvailable(ctx : ConnectionavailableContext) : ConnectionAvailable = factory.createConnectionAvailable().apply {
        val (type,chain) = visitObjectReference(ctx.objectreference())
        this.type = type as? AssetType ?: throw ClassCastException("Expected Asset")
        this.referenceChain += chain
    }

    /**
     * Follows the given reference in the CySeMoL PRM, returns an analysis model instance
     */
    fun visitObjectReference(ctx : ObjectreferenceContext) : ReferenceChain = ctx.ID().map {
        it.text
    }.fold ( //follow the connection chain, starting with the root class
            ReferenceChain(codeOwner,listOf())
    ) { currentChain, childId ->
        //follow the edges, or throw an exception
        val label = childId.toLowerCase()
        currentChain.destinationType.connectedTo.filter {
            it.label.toLowerCase() == label
        }.singleOrNull()?.let { //null-safe invocation
            ReferenceChain(it.target,currentChain.refs + it)
        } ?: throw RuntimeException("Non-existing reference '$childId' while parsing ${ctx.text}")

    }

    data class ReferenceChain(val destinationType: ConcreteType, val refs : List<ConcreteConnection>)


    private fun  visitProbabilityDistributionReference(id: TerminalNode): ProbabilityReference = factory.createProbabilityReference().apply {
        // Lookup the reference, and test whether there is only one distribution with this name
        this.refersTo = root!!.distributions.filter { it.name == id.text }.single()
    }



    fun visitBooleanoperand(ctx: BooleanoperandContext): Constant = when{
        ctx.TRUE()!=null -> factory.createConstant().apply { value = 1.0 }
        ctx.FALSE()!=null -> factory.createConstant().apply { value = 0.0 }
        else -> edgeCaseFailWithContext(ctx)
    }

    fun visitNumberoperand(ctx: P2AMFParser.NumberoperandContext): Constant = factory.createConstant().apply {
        value = ctx.text.toDouble() //parse ints and doubles
    }

    fun visitProbabilitydistribution(ctx: ProbabilitydistributionContext): ProbabilityDefinition = when{
        //Probability distributions nested in a bernoulli() block
        ctx.probabilitydistribution()!=null -> visitProbabilitydistribution(ctx.probabilitydistribution())

       //Single distribution
        ctx.bernoullidist()!=null -> visitBernoullidist(ctx.bernoullidist())
        ctx.lineardist()!=null -> visitLineardist(ctx.lineardist())
        ctx.expdist()!=null -> visitExpdist(ctx.expdist())
        ctx.normaldist()!=null -> visitNormalDistribution(ctx.normaldist())
        ctx.lognormaldist()!=null -> visitLogNormalDistribution(ctx.lognormaldist())
        ctx.gammadist()!=null -> visitGammaDistribution(ctx.gammadist())
        else -> edgeCaseFailWithContext(ctx)
    }

    fun visitLineardist(ctx: LineardistContext): LinearApproximation {
        return factory.createLinearApproximation().apply {
            val xArray = ctx.x
            val yArray = ctx.y

            xArray.numberoperand().forEachIndexed { index, numop ->
                this.approximationpoints += factory.createApproximationPoint().apply {
                    this.x = visitNumberoperand(numop).value
                    this.y = visitNumberoperand(yArray.numberoperand(index)).value
                }
            }
        }
    }

    fun visitBernoullidist(ctx: BernoullidistContext): Bernoulli = factory.createBernoulli().apply {
        this.probability = visitNumberoperand(ctx.numberoperand()).value
    }

    fun visitExpdist(ctx: ExpdistContext): ExponentialCDF = factory.createExponentialCDF().apply {
        this.lambda = visitNumberoperand(ctx.lambda).value
    }

    fun visitNormalDistribution(ctx : NormaldistContext) : NormalPDF = factory.createNormalPDF().apply {
        mu = visitNumberoperand(ctx.mu).value
        sigma = visitNumberoperand(ctx.sigma).value
    }

    fun visitLogNormalDistribution(ctx : LognormaldistContext) : LogNormalCDF = factory.createLogNormalCDF().apply {
        mu = visitNumberoperand(ctx.mu).value
        sigma = visitNumberoperand(ctx.sigma).value
    }

    fun visitGammaDistribution(ctx : GammadistContext) : GammaCDF = factory.createGammaCDF().apply {
        alpha = visitNumberoperand(ctx.alpha).value
        beta = visitNumberoperand(ctx.beta).value
    }

    /**
     * Throws an exception with the given parser context in its message
     * Called when all cases in a when {} block have been exhausted
     */
    private fun edgeCaseFailWithContext(ctx: ParserRuleContext) : Nothing {
        throw IllegalStateException("Unsupported edge case in ${ctx.text}")
    }
}