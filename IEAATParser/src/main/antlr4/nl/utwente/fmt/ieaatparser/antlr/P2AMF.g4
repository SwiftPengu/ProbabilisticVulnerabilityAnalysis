grammar P2AMF;

program :
    letblock* expression EOF
;

letblock:
    'let' ID ':' type '=' probabilitydistribution 'in'?
;

//Explicitly left-recursive, let ANTLR4 take care of it
expression:
     left=expression AND right=expression
    | left=expression OR right=expression
    | NOT expr=expression
    | ifthenelse
    | operands
    | '(' expression ')'
;

operands:  booleanoperand
              | numberoperand
              | reference;

ifthenelse:
    'if' condition=expression 'then'
        t=expression
    'else'
        f=expression 'endif';

probabilitydistribution:
    //Inline distributions wrapped in a bernoulli distribution
    'bernoulli' '(' probabilitydistribution ')'
    | ('self' '.')? (
        lineardist
        | expdist
        | lognormaldist
        | normaldist
        | gammadist
        | bernoullidist
    )
;

reference:
    attackstepEnabled
    | attackstep
    | defence
    | connectionavailable
    | ID;

connectionavailable: objectreference '->' 'notEmpty' '(' ')';

attackstep:
    'visited'
        '->' 'intersection' '(' objectreference ')'
        '->' 'notEmpty' '(' ')';

attackstepEnabled:
    'visited'
        '->' 'intersection' '(' 'self' '.' 'source' ')'
        '->' 'notEmpty' '(' ')';

defence: 'defenseAvailable' '(' objectreference  '->' 'asSet' '(' ')' ')';

objectreference:
    ('self' '.')? (ID '.')* ID;


//distributions
bernoullidist:
    'bernoulli'
        '(' p=numberoperand ')';

expdist:
    'exp'
        '(' lambda=numberoperand ',' attackertime ')';

lineardist:
    'linear'
        '(' x=arrayexpression ',' y=arrayexpression ',' attackertime ')';

normaldist:
    'normal'
        '(' mu=numberoperand ',' sigma=numberoperand ',' attackertime ')';

lognormaldist:
    'lognormal'
        '(' mu=numberoperand ',' sigma=numberoperand ',' attackertime ')';

gammadist:
    'gamma'
        '(' alpha=numberoperand ',' beta=numberoperand ',' attackertime ')';

arrayexpression:
    '[' numberoperand (',' numberoperand)* ']' ;

//constants
booleanoperand:
     TRUE
    |FALSE;

numberoperand:
    DASH? (intop | doubleop);

intop:
    NUMBER ;

doubleop:
    NUMBER '.' NUMBER;

type:
    'Real'
    | 'Bool'
    | 'Int';

attackertime:
    'Attacker' '.' 'Time';

//Named tokens
//Only define those which are required to be referenced from the AST
DASH: '-';
AND : 'and';
OR : 'or';
NOT : 'not';
TRUE : 'true';
FALSE : 'false';
CHAR: 'a'..'z' | 'A'..'Z';
NUMBER: DIGIT+;
DIGIT: [0-9];
ID : CHAR (CHAR | NUMBER | '_')* ;
WS : [ \t\r\n]+ -> skip ; // skip spaces, tabs, newlines
COMMENT : DASH DASH ~[\r\n]* -> skip;
